{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function mapTo(value) {\n  return function (source) {\n    return source.lift(new MapToOperator(value));\n  };\n}\n\nvar MapToOperator = /*@__PURE__*/function () {\n  function MapToOperator(value) {\n    this.value = value;\n  }\n\n  MapToOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new MapToSubscriber(subscriber, this.value));\n  };\n\n  return MapToOperator;\n}();\n\nvar MapToSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(MapToSubscriber, _super);\n\n  function MapToSubscriber(destination, value) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.value = value;\n    return _this;\n  }\n\n  MapToSubscriber.prototype._next = function (x) {\n    this.destination.next(this.value);\n  };\n\n  return MapToSubscriber;\n}(Subscriber);","map":{"version":3,"sources":["C:\\Users\\ASUS\\Desktop\\D'ARTDECO\\frontend\\node_modules\\rxjs\\src\\internal\\operators\\mapTo.ts"],"names":[],"mappings":";AACA,OAAO,KAAE,OAAT,MAAqB,OAArB;AAoCA,SAAM,UAAN,QAAoC,eAApC;AACE,OAAA,SAAO,KAAP,CAAQ,KAAR,EAA6B;AAC9B,SAAA,UAAA,MAAA,EAAA;AAAA,WAAA,MAAA,CAAA,IAAA,CAAA,IAAA,aAAA,CAAA,KAAA,CAAA,CAAA;AAAA,GAAA;AAED;;IAIE,aAAA,GAAA,aAAoB,YAAA;AAClB,WAAK,aAAL,CAAmB,KAAnB,EAAmB;AACpB,SAAA,KAAA,GAAA,KAAA;AAED;;AACE,EAAA,aAAO,CAAA,SAAP,CAAc,IAAd,GAAwB,UAAI,UAAJ,EAAoB,MAApB,EAAgC;AACzD,WAAA,MAAA,CAAA,SAAA,CAAA,IAAA,eAAA,CAAA,UAAA,EAAA,KAAA,KAAA,CAAA,CAAA;AACH,GAFI;;AAEH,SAAA,aAAA;AAOD,CAdsB,E;;IAcc,eAAA,GAAA,aAAA,UAAa,MAAb,EAAa;AAI/C,EAAA,OAAA,CAAA,SAAA,CAAA,eAAA,EAAY,MAAZ;;AAAA,WAAA,eAAA,CACE,WADF,EACQ,KADR,EACmB;AACjB,QAAA,KAAK,GAAK,MAAG,CAAK,IAAR,CAAS,IAAT,EAAS,WAAT,KAAS,IAAnB;;;AACD,WAAA,KAAA;AAED;;AACE,EAAA,eAAK,CAAA,SAAL,CAAsB,KAAtB,GAA2B,UAAO,CAAP,EAAO;AACnC,SAAA,WAAA,CAAA,IAAA,CAAA,KAAA,KAAA;AACH,GAFI;;AAVgC,SAAA,eAAA;CAAA,C,UAAA,C","sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * ![](mapTo.png)\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * ## Example\n * Map every click to the string 'Hi'\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { mapTo } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const greetings = clicks.pipe(mapTo('Hi'));\n * greetings.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nexport function mapTo<T, R>(value: R): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new MapToOperator(value));\n}\n\nclass MapToOperator<T, R> implements Operator<T, R> {\n\n  value: R;\n\n  constructor(value: R) {\n    this.value = value;\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapToSubscriber(subscriber, this.value));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapToSubscriber<T, R> extends Subscriber<T> {\n\n  value: R;\n\n  constructor(destination: Subscriber<R>, value: R) {\n    super(destination);\n    this.value = value;\n  }\n\n  protected _next(x: T) {\n    this.destination.next(this.value);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}